#include "trig_funcs.h"

#include "func_expr.h"
#include "binary_op.h"


//////////////////////////////////////////////////////////////
/////////////////////////////Sine/////////////////////////////
//////////////////////////////////////////////////////////////


template <typename T>
cFuncExpr cSine<T>::derivative(const cVariable &var)const
{
	return cFuncExpr(Composition(), cCosine<T>(), var);
}

template <typename T>
cFuncExpr cSine<T>::primitive(const cVariable &var)const
{
	return cFuncExpr(Multiplication(), -1, cFuncExpr(Composition(), cCosine<T>(), var));
}

template <typename T>
cAsine<T> cSine<T>::inverse()const
{
	return cAsine<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
/////////////////////////////Cosine/////////////////////////////
//////////////////////////////////////////////////////////////

template <typename T>
cFuncExpr cCosine<T>::derivative(const cVariable &var)const
{
	return cFuncExpr(Multiplication(), -1, cFuncExpr(Composition(), cSine<T>(), var));
}

template <typename T>
cFuncExpr cCosine<T>::primitive(const cVariable &var)const
{
	return cFuncExpr(Composition(), cSine<T>(), var);
}

template <typename T>
cAcosine<T> cCosine<T>::inverse()const
{
	return cAcosine<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////
////////////////////////////Tangent///////////////////////////
//////////////////////////////////////////////////////////////

template <typename T>
cFuncExpr cTangent<T>::derivative(const cVariable &var)const
{
	return cFuncExpr(Division(), 1, cFuncExpr(Multiplication(), 
				cFuncExpr(Composition(), cCosine<T>(), var), cFuncExpr(Composition(), cCosine<T>(), var)));
}

template <typename T>
cFuncExpr cTangent<T>::primitive(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Composition(), cTangent<T>(), var);
}

template <typename T>
cAtangent<T> cTangent<T>::inverse()const
{
	return cAtangent<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
/////////////////////////////Asine////////////////////////////
//////////////////////////////////////////////////////////////

template <typename T>
cFuncExpr cAsine<T>::derivative(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Division(), 1.0, cFuncExpr(Composition(), cAsine<T>(), var));
}

template <typename T>
cFuncExpr cAsine<T>::primitive(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Composition(), cSine<T>(), var);
}

template <typename T>
cSine<T> cAsine<T>::inverse()const
{
	return cSine<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
////////////////////////////Acosine///////////////////////////
//////////////////////////////////////////////////////////////

template <typename T>
cFuncExpr cAcosine<T>::derivative(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Division(), 1, cFuncExpr(Composition(), cAsine<T>(), var));
}

template <typename T>
cFuncExpr cAcosine<T>::primitive(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Composition(), cSine<T>(), var);
}

template <typename T>
cCosine<T> cAcosine<T>::inverse()const
{
	return cCosine<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
////////////////////////////Atangent///////////////////////////
//////////////////////////////////////////////////////////////

template <typename T>
cFuncExpr cAtangent<T>::derivative(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Division(), 1, cFuncExpr(Composition(), cAsine<T>(), var));
}

template <typename T>
cFuncExpr cAtangent<T>::primitive(const cVariable &var)const
{
	//TODO
	return cFuncExpr(Composition(), cCosine<T>(), var);
}

template <typename T>
cTangent<T> cAtangent<T>::inverse()const
{
	return cTangent<T>();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


template class cSine<double>;

template class cCosine<double>;

template class cTangent<double>;

template class cAsine<double>;

template class cAcosine<double>;

template class cAtangent<double>;


